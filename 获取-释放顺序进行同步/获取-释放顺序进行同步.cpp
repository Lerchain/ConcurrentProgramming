#include "pch.h"
#include <iostream>
#include <atomic>
#include <thread>
#include <Windows.h>
#include <mutex>
#include <chrono>
using namespace std;

atomic<bool> x=false, y = false, start = false;
atomic<int> X1;
int X,Y;

void writeX()
{
	while (!start.load(memory_order_relaxed));
	X++;
	X1.store(X1 + 1, memory_order_relaxed);
	x.store(true, memory_order_release);
}

void writeY()
{
	while (!start.load(memory_order_relaxed));
	Y++;
	y.store(true, memory_order_release);
}

void readYthenX()
{
	while (!start.load(memory_order_relaxed));
	while (!y.load(memory_order_acquire));
	if (x.load(memory_order_acquire))
		cout << "X has synchronized";
	else
		cout << "X does not have synchronzed";
	cout << X;
	cout << X1.load(memory_order_relaxed);
}
mutex m;
int main()
{
	lock_guard<mutex>lk(m);
	//最有趣的情况出现了， x还是0的情况下 X是1. 为什么啊？
	//是否是因为X不是原子变量，即使是release-acquire也无法保证获取不会乱序。
	//擦，用了原子变量X1也是这个鸟样。不对啊，获取-释放顺序不是保证了释放之前的数据也会跟着获取一并更新的吗？那不可能出现。啊！！！我知道了！是释放之后获取时会更新。
	//当出现x acquire后是false的情况时代表x还没有release呢，当然就无法保证X,或者X1获取时会是什么状态。
	//release-acquire需要一起使用的，为什么要一起使用？release相当于把当前线程下release之前所有的数据实时更新了以下，但要特别注意的是，是只有调用acquire的那个线程会看到这个更新。
	//所以他俩当然要一起使用了，你光release，不acquire，其他线程获取的都是乱序的，release等于relaxed了，你光acquire不release，acquire的也是relaxed的。
	//那你说为什么要这么搞，release直接给全线程更新就得了呗，要啥acquire啊。
	//理想很美好，我们首先仔细想下，relaxed为什么要存在？我看很多篇文章的意思是relaxed什么都不保证，跟正常存一样。其实这就是它的保证，它保证了速度。
	//什么叫不保证：当你用relaxed存这个数据的时候意味着其他线程如果load这个数据，它load的值是无法确定的，或许是你刚load的，也或许是你之前load的。
	//这种情况是很常见的，因为是多线程并发，共享的全局变量刚被这个线程读，另一个线程就把它改了，那读的这个线程读到的准定就不是最新的了。
	//这当然不好，但是这样多线程并发速度才会快啊，如果想要读到的都是实时更新的数据，就得保证先写，写完再读，确实能保证，可如果所有的数据都是如此，不就变成单线程了嘛，也就是所谓的序列化。
	//所以有些数据，该更新时得更新，没这必要时就用relaxed存。这就是relaxed的作用。
	//如果真的需要全线程都知道我这数据更新了，那就用seq。seq是原子变量默认的存储方式，是顺序的。顺序的意思就是，我这用seq存了，ok,你其他线程要load这个数据，load到的一定会是我这存的。
	//当然了，如果还有一个线程在我用seq存了这数据后，它也用seq把这数据改了，那ok，他是大哥了，等着load的就是他存的。
	//没错，如果所有数据都是这样用seq存，效率可想而知。并且这个seq，就是最开始所想的那个一次release，所有线程更新。
	//所以release-acquire也就应运而生了。我release是对所有线程relaxed,唯独对acquire的线程seq。效率与有序双丰收，欸美滋滋。
	//那最终极的问题出现了，这些存取方式到底怎么实现的？
	//首先是relaxed，这个最好想，它的方式就是没有方式。就正常存就行。
	//怎么叫正常就行呢，首先大家一定要明确的一点就是，我们所写的代码，执行起来可不是我们写的顺序，甚至不是我们写的东西。
	//只要不真正的影响语义，编译器和CPU是乱序执行的。不是真正的随便乱着来。他们给咱优化了，比如说int x=1; x=2;
	//编译器觉得你这x赋值了个1,然后又赋值2，那赋1没得卵用，就给你优化掉了！
	//人家初衷是好的，而且确实给咱提速了，但是这在多线程的环境下就是个噩梦，我举个最简单的例子，这个线程下本来是x = true; y = false;
	//编译器，或者CPU，人家正好就是认为反过来速度快（那就确实会快），然后就给你变成了 y = false; x = true;这在单线程下没啥，因为单线程内，这个x,y谁先赋值无所谓
	//人家是了解这点的所以才敢给你换，但多线程情况下，每一个线程依旧会认为自己是单线程的，因为线程是CPU调度的最小单位，他们以为他们自己就是整个宇宙。
	//所以这个宇宙是意识不到另一个平行宇宙内正在判断y是不是false,y要是false另一个宇宙就认为x准定是true，这样毛病不就大了么，另一个宇宙可不知道x已经被编译器/CPU好心的交换到y的后面了。
	//这就是乱序。正常存就行的意思就是指，就这么乱序的存，就行。但也还是有区别的，原子变量之所以叫原子变量，就是因为所有对它的操作都得是原子性的。
	//也就是说，你使用原子变量会保证，这个变量在被这个线程存的时候，其他线程不能存，只能读。
	//这就很有用了，正常变量可保证不了这点，正常变量是存在被这个线程写了一半时，另一个线程又开始写它的情况的，这不就窜了么，结果不得而知反正是灾难性的。
	//说完relaxed，再谈seq，seq可是原子类型默认的存储方式。它必然有着默认的道理。
	//一个程序能够正常的运行下来，必然是顺序执行下去的，乱序也是只单线程在顺序的基础上乱，这是无伤大雅甚至锦上添花的。可在多线程的情况下，这一无伤大雅的乱，可就真的乱了，所以会将seq置为默认。
	//因为seq能够保证我用seq存的就是顺序的，所有线程读都是顺序的，我seq不会乱。
	//我发现我也只能说到此了，因为我目前好像还真不能说清它再底层是咋实现的，Herb Sutter有个专门的演讲，我看过一点，大致的猜测一下：
	//首先我们先想，线程是CPU调度的最小单位，进程才是资源调度的最小单位，线程之间是共享内存的，而程序在运行时内存分配有3种（我前些天正好还写了篇博客）：栈，堆，静态存储区。
	//而那些线程内的局部变量明显是存在了栈，你自己手工创建的（new/malloc)存在了堆，这些都不用管，需要管的是存在了静态存储区的全局变量。
	//我们存的都是这些存在静态存储区的全局变量。（从此以下的言论，或不属实，还望大佬指点）
	//根据Herb的意思（好像是），我们存一个变量时（以下称数据），其实不会直接就更新内存，这里的内存指的是主存。相信大家都知道或者听说过cache吧。
	//CPU的运算速度是巨快的，如果CPU直接存储给主存，着实大材小用，因为需要写数据给主存，I/O时间会显的很长，这时cache（高速缓存）就登场了，CPU快速的把数据写入cache，然后它就可以继续做其他事了
	//cache也分级别的，L1,L2,L3，层层递进，最后存到主存。级别不是关键，关键是我们要知道CPU不是直接和内存沟通的，其实这就是乱序的根源！
	//要知道主存内的那3个区可才是真正存数据的地方啊。你CPU等于说为了提高效率，还没真正存呢，就干别的事去了。就乱序了呗。单线程没事，多线程是大事。
	//而且是避免不了的大事，因为这是“CPU自作主张这么干的！你再怎么限制编译器都没有用”（Herb Sutter原话）。
	//欸那要这么说岂不是就没辙了，那seq是咋保证的有序的啊。。。
	//好像想的稍有错了，我们再想想乱序到底是怎么形成的。CPU把数据存入高速缓存，之后就干别的事了，如果接下来的事还得用到刚存的数据，CPU会从高速缓存中调还是主存？
	//当然会从cache，因为它知道在它这个宇宙里，它刚存的数据还在cache里呢，主存里的是旧的。可多线程下不只有它这个宇宙，别的宇宙或许正好也需要这个数据，然后它就只能从主存拿，
	//因为别的宇宙可不知道cache里存的是新数据。结果是会出现什么情况。我这个线程已经把这个数据给写了，并且判断条件都通过了。你那线程，明明是同一时间相同的数据相同的判断条件，就是不通过。
	//这算是乱序吗，说到这里我都有点懵了，乱序指的是语句之间好像调换了顺序一样执行。我这个例子好像不太对，那我们再回到问题的初始，如何实现seq，为什么要实现seq,为了保证每次读到的数据都是正确的数据。
	//读到的是所有线程，最后更新这个数据的线程更新的数据值。而我刚才描述的那个问题正是为什么线程会读到未更新的数据！
	//也就是说我只要保证线程读到的是实时的数据就行了。也就是说，seq应该是可以保证store时CPU彻底的存到主存！（猜测1），这个过程是原子的，所以其他线程再读时读到的都会是新的。（话说真的可以这么保证么）
	//那load()用seq也是从主存load!(猜测2)。
	//那relaxed就是正常的cache中有就从cache中读，没有就从主存读，写也是正常先写入cache,逐级到主存。（猜测3）
	//release和acquire就有意思了。release应该是存两份，一份正常存（先存在cache中，逐级存主存）供那些不打算使用acquire来load的线程来load，一份用seq的方式一口气存到主存。
	//而acquire能保证从主存load（）（猜测4）。
	thread t3(readYthenX); // 这个线程顺序稍显重要，毕竟程序简单，初始化线程不是同时的。
	thread t1(writeX);
	thread t2(writeY);
	//this_thread::sleep_for(chrono::milliseconds(1000));
	Sleep(1000);
	start = true; //所以让它们同时启动。 但发现没有用，t3在t1之上就是0，否则就是1，为什么呢，我都让三个线程同时起步了。
	//会不会是t1线程还没创建完，start就true了。
	//事实证明不是，睡了1s都不行。
	//会不会Sleep是全线程睡呢？换成chrono试试
	//我佛了，我说怎么chrono都能先输出，又等了1S结束，start初始我就设成了true！！！我个zz。
	//那Sleep应该也行的吧。
	t1.join();
	t2.join();
	t3.join();
}